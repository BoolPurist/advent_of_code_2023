pub fn handle_task(input: String) -> String {
    let parsed = parse(&input);
    parsed
        .iter()
        .map(get_seqs)
        .map(|seqs| calculate_score_of(&seqs))
        .sum::<u32>()
        .to_string()
}
pub fn handle_task_2(input: String) -> String {
    let parsed = parse(&input);
    let plot: Vec<(usize, Vec<usize>)> = parsed
        .iter()
        .map(get_seqs)
        .enumerate()
        .map(|(index, seqs)| (0, next_seq(index, &seqs)))
        .collect();

    for index in 0..plot.len() {
        let (count, seq) = plot.get(index).unwrap();
        for next_card in seq.iter() {
            l
        }
    }

    return format!("{:#?}", plot);
    fn next_seq(index: usize, seqs: &[u32]) -> Vec<usize> {
        let start = index + 2;
        let end = start + seqs.len();
        (start..end).collect()
    }
}
fn get_seqs(cards: &Card) -> Vec<u32> {
    cards
        .actual
        .iter()
        .filter(|&next| cards.winning.contains(next))
        .cloned()
        .collect()
}
fn get_winnig_indexes(cards: &Card) -> Vec<usize> {
    cards
        .actual
        .iter()
        .filter_map(|&next| {
            cards
                .winning
                .iter()
                .position(|&ele| ele == next)
                .map(|index| index + 1)
        })
        .collect()
}

fn calculate_score_of(points: &[u32]) -> u32 {
    if points.is_empty() {
        return 0;
    }
    let mut val = 1;
    for _ in 1..points.len() {
        val *= 2;
    }
    val
}

fn parse(input: &str) -> Vec<Card> {
    input
        .lines()
        .map(|line| {
            let mut numbers = line.trim().split(":").skip(1).next().unwrap().split("|");

            let (winning, actual) = (numbers.next().unwrap(), numbers.next().unwrap());
            let winning = split_numbers(winning);
            let actual = split_numbers(actual);
            return Card { winning, actual };
            fn split_numbers(input: &str) -> Vec<u32> {
                input
                    .split_whitespace()
                    .map(|number| number.parse::<u32>().unwrap())
                    .collect()
            }
        })
        .collect()
}

#[derive(Debug)]
struct Card {
    winning: Vec<u32>,
    actual: Vec<u32>,
}
#[cfg(test)]
mod testing {
    use super::*;

    #[test]
    fn day_4_parse() {
        let input = "Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53";
        let parsed = parse(input);
        insta::assert_debug_snapshot!(parsed);
    }
    #[test]
    fn day_4_get_seqs() {
        let input = "Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53";
        let parsed = parse(input);
        let actual = get_seqs(parsed.get(0).unwrap());
        let expected: Vec<u32> = vec![83, 86, 17, 48];
        assert_eq!(expected, actual);
    }
    #[test]
    fn day_4_get_score_of() {
        assert_case(&[1, 2, 3, 4], 8);
        assert_case(&[], 0);
        assert_case(&[1, 2], 2);
        fn assert_case(input: &[u32], expected: u32) {
            let actual = calculate_score_of(input);
            assert_eq!(expected, actual, "Input: {:?}", input);
        }
    }
}
